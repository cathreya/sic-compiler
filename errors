In file included from scanner.l:7:0:
parser.y:25:2: error: ‘Term’ does not name a type
  Term *TermVal;
  ^~~~
parser.y:26:2: error: ‘Name’ does not name a type; did you mean ‘time’?
  Name *NameVal;
  ^~~~
  time
parser.y:27:2: error: ‘Float’ does not name a type; did you mean ‘float’?
  Float *FloatVal;
  ^~~~~
  float
parser.y:28:2: error: ‘Int’ does not name a type; did you mean ‘int’?
  Int *IntVal;
  ^~~
  int
parser.y:29:2: error: ‘Bool’ does not name a type; did you mean ‘bool’?
  Bool *BoolVal;
  ^~~~
  bool
parser.y:30:2: error: ‘Char’ does not name a type; did you mean ‘char’?
  Char *CharVal;
  ^~~~
  char
parser.y:31:2: error: ‘MultiDimArr’ does not name a type
  MultiDimArr *MultiDimArrVal;
  ^~~~~~~~~~~
parser.y:32:2: error: ‘UnaryTerm’ does not name a type
  UnaryTerm *UnaryTermVal;
  ^~~~~~~~~
parser.y:33:2: error: ‘Exp’ does not name a type
  Exp *ExpVal;
  ^~~
parser.y:34:2: error: ‘BinaryOperator’ does not name a type
  BinaryOperator *BinaryOperatorVal;
  ^~~~~~~~~~~~~~
parser.y:35:2: error: ‘TernaryOperator’ does not name a type
  TernaryOperator *TernaryOperatorVal;
  ^~~~~~~~~~~~~~~
parser.y:36:7: error: ‘vector’ in namespace ‘std’ does not name a template type
  std::vector<Square*> *SquareVal;
       ^~~~~~
parser.y:37:2: error: ‘FuncCall’ does not name a type; did you mean ‘syscall’?
  FuncCall *FuncCallVal;
  ^~~~~~~~
  syscall
parser.y:38:2: error: ‘String’ does not name a type; did you mean ‘stdin’?
  String *StringVal;
  ^~~~~~
  stdin
parser.y:39:7: error: ‘vector’ in namespace ‘std’ does not name a template type
  std::vector<Arg*> *ArgVal;
       ^~~~~~
parser.y:40:2: error: ‘IfStmt’ does not name a type
  IfStmt *IfStmtVal;
  ^~~~~~
parser.y:41:2: error: ‘For’ does not name a type
  For *ForVal;
  ^~~
parser.y:42:2: error: ‘While’ does not name a type
  While *WhileVal;
  ^~~~~
parser.y:43:2: error: ‘AssignPar’ does not name a type
  AssignPar *AssignParVal;
  ^~~~~~~~~
parser.y:44:2: error: ‘ArrayAssign’ does not name a type
  ArrayAssign *ArrayAssignVal;
  ^~~~~~~~~~~
parser.y:45:2: error: ‘Assign’ does not name a type
  Assign *AssignVal;
  ^~~~~~
parser.y:46:2: error: ‘Break’ does not name a type; did you mean ‘pread’?
  Break *BreakVal;
  ^~~~~
  pread
parser.y:47:2: error: ‘Continue’ does not name a type; did you mean ‘optind’?
  Continue *ContinueVal;
  ^~~~~~~~
  optind
parser.y:48:2: error: ‘Return’ does not name a type; did you mean ‘setuid’?
  Return *ReturnVal;
  ^~~~~~
  setuid
parser.y:49:2: error: ‘Statement’ does not name a type
  Statement *StatementVal;
  ^~~~~~~~~
parser.y:50:7: error: ‘vector’ in namespace ‘std’ does not name a template type
  std::vector<Statement*> *StatementListVal;
       ^~~~~~
parser.y:51:7: error: ‘vector’ in namespace ‘std’ does not name a template type
  std::vector<Param*> *ParamVal;
       ^~~~~~
parser.y:52:2: error: ‘FuncDef’ does not name a type
  FuncDef *FuncDefVal;
  ^~~~~~~
parser.y:53:7: error: ‘vector’ in namespace ‘std’ does not name a template type
  std::vector<ProgramNode*> *ProgramNodeVal;
       ^~~~~~
parser.y:54:2: error: ‘ProgramNode’ does not name a type
  ProgramNode *SProgramNodeVal;
  ^~~~~~~~~~~
parser.y:55:7: error: ‘vector’ in namespace ‘std’ does not name a template type
  std::vector<Imports*> *ImportsVal;
       ^~~~~~
parser.y:56:2: error: ‘StartNode’ does not name a type; did you mean ‘strtod’?
  StartNode *StartNodeVal;
  ^~~~~~~~~
  strtod
parser.y: In function ‘int yyparse()’:
parser.y:126:87: error: no matching function for call to ‘StartNode::StartNode(std::vector<Imports*>*&, std::vector<ProgramNode*>*&)’
  $$ = new StartNode($1,$2);
                                                                                       ^
In file included from parser.y:6:0:
ast.h:725:2: note: candidate: StartNode::StartNode(Node*, Node*)
  StartNode(Node *imports, Node *defns){
  ^~~~~~~~~
ast.h:725:2: note:   no known conversion for argument 1 from ‘std::vector<Imports*>*’ to ‘Node*’
ast.h:723:7: note: candidate: constexpr StartNode::StartNode(const StartNode&)
 class StartNode: public Node{
       ^~~~~~~~~
ast.h:723:7: note:   candidate expects 1 argument, 2 provided
parser.y:130:49: error: cannot convert ‘std::vector<ProgramNode*>*’ to ‘StartNode*’ in assignment
  $$ = $1;
                                                 ^
parser.y:134:95: error: no matching function for call to ‘std::__cxx11::basic_string<char>::basic_string(String*&)’
 imports : IMPORT string STMT_SEP {$$ = new std::vector<Imports*> {Imports(std::string($2))};}
                                                                                               ^
In file included from /usr/include/c++/7/string:52:0,
                 from /usr/include/c++/7/bits/locale_classes.h:40,
                 from /usr/include/c++/7/bits/ios_base.h:41,
                 from /usr/include/c++/7/ios:42,
                 from /usr/include/c++/7/ostream:38,
                 from /usr/include/c++/7/iostream:39,
                 from parser.y:4:
/usr/include/c++/7/bits/basic_string.h:604:9: note: candidate: template<class _InputIterator, class> std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(_InputIterator, _InputIterator, const _Alloc&)
         basic_string(_InputIterator __beg, _InputIterator __end,
         ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:604:9: note:   template argument deduction/substitution failed:
parser.y:134:95: note:   candidate expects 3 arguments, 1 provided
 imports : IMPORT string STMT_SEP {$$ = new std::vector<Imports*> {Imports(std::string($2))};}
                                                                                               ^
In file included from /usr/include/c++/7/string:52:0,
                 from /usr/include/c++/7/bits/locale_classes.h:40,
                 from /usr/include/c++/7/bits/ios_base.h:41,
                 from /usr/include/c++/7/ios:42,
                 from /usr/include/c++/7/ostream:38,
                 from /usr/include/c++/7/iostream:39,
                 from parser.y:4:
/usr/include/c++/7/bits/basic_string.h:566:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]
       basic_string(basic_string&& __str, const _Alloc& __a)
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:566:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/basic_string.h:562:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]
       basic_string(const basic_string& __str, const _Alloc& __a)
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:562:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/basic_string.h:558:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::initializer_list<_Tp>, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]
       basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc())
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:558:7: note:   no known conversion for argument 1 from ‘String*’ to ‘std::initializer_list<char>’
/usr/include/c++/7/bits/basic_string.h:531:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]
       basic_string(basic_string&& __str) noexcept
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:531:7: note:   no known conversion for argument 1 from ‘String*’ to ‘std::__cxx11::basic_string<char>&&’
/usr/include/c++/7/bits/basic_string.h:519:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, _CharT, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]
       basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc())
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:519:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/basic_string.h:509:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]
       basic_string(const _CharT* __s, const _Alloc& __a = _Alloc())
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:509:7: note:   no known conversion for argument 1 from ‘String*’ to ‘const char*’
/usr/include/c++/7/bits/basic_string.h:499:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _CharT*, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]
       basic_string(const _CharT* __s, size_type __n,
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:499:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/basic_string.h:481:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]
       basic_string(const basic_string& __str, size_type __pos,
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:481:7: note:   candidate expects 4 arguments, 1 provided
/usr/include/c++/7/bits/basic_string.h:465:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]
       basic_string(const basic_string& __str, size_type __pos,
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:465:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/basic_string.h:450:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&, std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type, const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>; std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::size_type = long unsigned int]
       basic_string(const basic_string& __str, size_type __pos,
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:450:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/basic_string.h:437:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const std::__cxx11::basic_string<_CharT, _Traits, _Alloc>&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]
       basic_string(const basic_string& __str)
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:437:7: note:   no known conversion for argument 1 from ‘String*’ to ‘const std::__cxx11::basic_string<char>&’
/usr/include/c++/7/bits/basic_string.h:429:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string(const _Alloc&) [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]
       basic_string(const _Alloc& __a) _GLIBCXX_NOEXCEPT
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:429:7: note:   no known conversion for argument 1 from ‘String*’ to ‘const std::allocator<char>&’
/usr/include/c++/7/bits/basic_string.h:420:7: note: candidate: std::__cxx11::basic_string<_CharT, _Traits, _Alloc>::basic_string() [with _CharT = char; _Traits = std::char_traits<char>; _Alloc = std::allocator<char>]
       basic_string()
       ^~~~~~~~~~~~
/usr/include/c++/7/bits/basic_string.h:420:7: note:   candidate expects 0 arguments, 1 provided
parser.y:134:97: error: no matching function for call to ‘std::vector<Imports*>::vector(<brace-enclosed initializer list>)’
 imports : IMPORT string STMT_SEP {$$ = new std::vector<Imports*> {Imports(std::string($2))};}
                                                                                                 ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:411:2: note: candidate: template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)
  vector(_InputIterator __first, _InputIterator __last,
  ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:411:2: note:   template argument deduction/substitution failed:
/usr/include/c++/7/bits/stl_vector.h:383:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Imports*>]
       vector(initializer_list<value_type> __l,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:383:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:358:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Imports*>]
       vector(vector&& __rv, const allocator_type& __m)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:358:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:348:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&, const allocator_type&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Imports*>]
       vector(const vector& __x, const allocator_type& __a)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:348:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:344:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>]
       vector(vector&& __x) noexcept
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:344:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:326:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>]
       vector(const vector& __x)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:326:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:295:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = Imports*; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Imports*>]
       vector(size_type __n, const value_type& __value,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:295:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:283:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const allocator_type&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Imports*>]
       vector(size_type __n, const allocator_type& __a = allocator_type())
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:283:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:270:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Imports*>]
       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:270:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:259:7: note: candidate: std::vector<_Tp, _Alloc>::vector() [with _Tp = Imports*; _Alloc = std::allocator<Imports*>]
       vector()
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:259:7: note:   candidate expects 0 arguments, 1 provided
parser.y:135:70: error: no matching function for call to ‘std::vector<Imports*>::push_back(Imports)’
 | imports IMPORT string STMT_SEP {$1->push_back(Imports($3)); $$ = $1;}
                                                                      ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>; std::vector<_Tp, _Alloc>::value_type = Imports*]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘Imports’ to ‘Imports* const&’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = Imports*; _Alloc = std::allocator<Imports*>; std::vector<_Tp, _Alloc>::value_type = Imports*]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘Imports’ to ‘Imports*&&’
parser.y:137:43: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘VarDecVal’; did you mean ‘NameVal’?
 prog_element : declaration STMT_SEP {$$ = $1;}
                                           ^~~~     
                                           NameVal
parser.y:138:52: error: cannot convert ‘FuncDef*’ to ‘ProgramNode*’ in assignment
 | function_definition {$$ = $1;}
                                                    ^
parser.y:140:82: error: no matching function for call to ‘ProgramNode::ProgramNode(ProgramNode*&)’
 program : program prog_element {$1->push_back(ProgramNode($2)); $$ = $1;}
                                                                                  ^
In file included from parser.y:6:0:
ast.h:680:2: note: candidate: ProgramNode::ProgramNode(Node*, Node*)
  ProgramNode(Node *element, Node *list){
  ^~~~~~~~~~~
ast.h:680:2: note:   candidate expects 2 arguments, 1 provided
ast.h:678:7: note: candidate: constexpr ProgramNode::ProgramNode(const ProgramNode&)
 class ProgramNode: public Node{
       ^~~~~~~~~~~
ast.h:678:7: note:   no known conversion for argument 1 from ‘ProgramNode*’ to ‘const ProgramNode&’
parser.y:141:100: error: no matching function for call to ‘ProgramNode::ProgramNode(ProgramNode*&)’
 | prog_element {$$ = new std::vector<ProgramNode*> {ProgramNode($1)};}
                                                                                                    ^
In file included from parser.y:6:0:
ast.h:680:2: note: candidate: ProgramNode::ProgramNode(Node*, Node*)
  ProgramNode(Node *element, Node *list){
  ^~~~~~~~~~~
ast.h:680:2: note:   candidate expects 2 arguments, 1 provided
ast.h:678:7: note: candidate: constexpr ProgramNode::ProgramNode(const ProgramNode&)
 class ProgramNode: public Node{
       ^~~~~~~~~~~
ast.h:678:7: note:   no known conversion for argument 1 from ‘ProgramNode*’ to ‘const ProgramNode&’
parser.y:141:101: error: no matching function for call to ‘std::vector<ProgramNode*>::vector(<brace-enclosed initializer list>)’
 | prog_element {$$ = new std::vector<ProgramNode*> {ProgramNode($1)};}
                                                                                                     ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:411:2: note: candidate: template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)
  vector(_InputIterator __first, _InputIterator __last,
  ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:411:2: note:   template argument deduction/substitution failed:
/usr/include/c++/7/bits/stl_vector.h:383:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<ProgramNode*>]
       vector(initializer_list<value_type> __l,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:383:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:358:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&) [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<ProgramNode*>]
       vector(vector&& __rv, const allocator_type& __m)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:358:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:348:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&, const allocator_type&) [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<ProgramNode*>]
       vector(const vector& __x, const allocator_type& __a)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:348:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:344:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&) [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>]
       vector(vector&& __x) noexcept
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:344:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:326:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>]
       vector(const vector& __x)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:326:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:295:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = ProgramNode*; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<ProgramNode*>]
       vector(size_type __n, const value_type& __value,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:295:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:283:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const allocator_type&) [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<ProgramNode*>]
       vector(size_type __n, const allocator_type& __a = allocator_type())
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:283:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:270:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<ProgramNode*>]
       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:270:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:259:7: note: candidate: std::vector<_Tp, _Alloc>::vector() [with _Tp = ProgramNode*; _Alloc = std::allocator<ProgramNode*>]
       vector()
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:259:7: note:   candidate expects 0 arguments, 1 provided
parser.y:143:13: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘VarDecVal’; did you mean ‘NameVal’?
 declaration : TYPE NAME ASSIGN string {$$ = new VarDec(std::string($1), NULL, std::string($2), $4);}
             ^~~~~~~~~
             NameVal
parser.y:144:13: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘VarDecVal’; did you mean ‘NameVal’?
 | TYPE NAME  {$$ = new VarDec(std::string($1), NULL, std::string($2), NULL);}
             ^~~~~~~~~
             NameVal
parser.y:145:13: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘VarDecVal’; did you mean ‘NameVal’?
 | TYPE NAME ASSIGN texp  {$$ = new VarDec(std::string($1), NULL, std::string($2), $4);}
             ^~~~~~~~~
             NameVal
parser.y:146:13: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘VarDecVal’; did you mean ‘NameVal’?
 | TYPE multidim NAME  {$$ = new VarDec(std::string($1), $2, std::string($3), NULL);}
             ^~~~~~~~~
             NameVal
parser.y:146:79: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 | TYPE multidim NAME  {$$ = new VarDec(std::string($1), $2, std::string($3), NULL);}
                                                                               ^~~~~~
                                                                               SquareVal
parser.y:148:143: error: no matching function for call to ‘FuncDef::FuncDef(std::__cxx11::string, std::__cxx11::string, std::vector<Param*>*&, Statement*&)’
 function_definition : TYPE NAME OPENPAREN parameters CLOSEPAREN statement_block {$$ = new FuncDef(std::string($1),std::string($2),$4,$6);}
                                                                                                                                               ^
In file included from parser.y:6:0:
ast.h:292:2: note: candidate: FuncDef::FuncDef(std::__cxx11::string, std::__cxx11::string, Node*, Node*)
  FuncDef(std::string type, std::string name, Node *params, Node *exec){
  ^~~~~~~
ast.h:292:2: note:   no known conversion for argument 3 from ‘std::vector<Param*>*’ to ‘Node*’
ast.h:290:7: note: candidate: FuncDef::FuncDef(const FuncDef&)
 class FuncDef: public Node{
       ^~~~~~~
ast.h:290:7: note:   candidate expects 1 argument, 4 provided
parser.y:151:143: error: no matching function for call to ‘FuncDef::FuncDef(std::__cxx11::string, std::__cxx11::string, std::vector<Param*>*&, Statement*&)’
 | VOIDV NAME OPENPAREN parameters CLOSEPAREN statement_block {$$ = new FuncDef(std::string($1),std::string($2),$4,$6);};
                                                                                                                                               ^
In file included from parser.y:6:0:
ast.h:292:2: note: candidate: FuncDef::FuncDef(std::__cxx11::string, std::__cxx11::string, Node*, Node*)
  FuncDef(std::string type, std::string name, Node *params, Node *exec){
  ^~~~~~~
ast.h:292:2: note:   no known conversion for argument 3 from ‘std::vector<Param*>*’ to ‘Node*’
ast.h:290:7: note: candidate: FuncDef::FuncDef(const FuncDef&)
 class FuncDef: public Node{
       ^~~~~~~
ast.h:290:7: note:   candidate expects 1 argument, 4 provided
parser.y:153:117: error: no matching function for call to ‘std::vector<Param*>::vector(<brace-enclosed initializer list>)’
 parameters : TYPE NAME {$$ = new vector<Param*> {Param(std::string($1), NULL, std::string($2))};}
                                                                                                                     ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:411:2: note: candidate: template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)
  vector(_InputIterator __first, _InputIterator __last,
  ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:411:2: note:   template argument deduction/substitution failed:
parser.y:153:117: note:   candidate expects 3 arguments, 1 provided
 parameters : TYPE NAME {$$ = new vector<Param*> {Param(std::string($1), NULL, std::string($2))};}
                                                                                                                     ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:383:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(initializer_list<value_type> __l,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:383:7: note:   no known conversion for argument 1 from ‘Param’ to ‘std::initializer_list<Param*>’
/usr/include/c++/7/bits/stl_vector.h:358:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(vector&& __rv, const allocator_type& __m)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:358:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:348:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(const vector& __x, const allocator_type& __a)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:348:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:344:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&) [with _Tp = Param*; _Alloc = std::allocator<Param*>]
       vector(vector&& __x) noexcept
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:344:7: note:   no known conversion for argument 1 from ‘Param’ to ‘std::vector<Param*>&&’
/usr/include/c++/7/bits/stl_vector.h:326:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = Param*; _Alloc = std::allocator<Param*>]
       vector(const vector& __x)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:326:7: note:   no known conversion for argument 1 from ‘Param’ to ‘const std::vector<Param*>&’
/usr/include/c++/7/bits/stl_vector.h:295:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = Param*; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(size_type __n, const value_type& __value,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:295:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:283:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(size_type __n, const allocator_type& __a = allocator_type())
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:283:7: note:   no known conversion for argument 1 from ‘Param’ to ‘std::vector<Param*>::size_type {aka long unsigned int}’
/usr/include/c++/7/bits/stl_vector.h:270:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:270:7: note:   no known conversion for argument 1 from ‘Param’ to ‘const allocator_type& {aka const std::allocator<Param*>&}’
/usr/include/c++/7/bits/stl_vector.h:259:7: note: candidate: std::vector<_Tp, _Alloc>::vector() [with _Tp = Param*; _Alloc = std::allocator<Param*>]
       vector()
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:259:7: note:   candidate expects 0 arguments, 1 provided
parser.y:154:93: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 | TYPE multidim NAME {$$ = new vector<Param*> {Param(std::string($1), $2, std::string($3))};}
                                                                                             ^     
                                                                                             SquareVal
parser.y:154:131: error: no matching function for call to ‘std::vector<Param*>::vector(<brace-enclosed initializer list>)’
 | TYPE multidim NAME {$$ = new vector<Param*> {Param(std::string($1), $2, std::string($3))};}
                                                                                                                                   ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:411:2: note: candidate: template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)
  vector(_InputIterator __first, _InputIterator __last,
  ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:411:2: note:   template argument deduction/substitution failed:
/usr/include/c++/7/bits/stl_vector.h:383:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(initializer_list<value_type> __l,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:383:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:358:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(vector&& __rv, const allocator_type& __m)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:358:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:348:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(const vector& __x, const allocator_type& __a)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:348:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:344:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&) [with _Tp = Param*; _Alloc = std::allocator<Param*>]
       vector(vector&& __x) noexcept
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:344:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:326:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = Param*; _Alloc = std::allocator<Param*>]
       vector(const vector& __x)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:326:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:295:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = Param*; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(size_type __n, const value_type& __value,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:295:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:283:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(size_type __n, const allocator_type& __a = allocator_type())
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:283:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:270:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Param*>]
       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:270:7: note:   conversion of argument 1 would be ill-formed:
/usr/include/c++/7/bits/stl_vector.h:259:7: note: candidate: std::vector<_Tp, _Alloc>::vector() [with _Tp = Param*; _Alloc = std::allocator<Param*>]
       vector()
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:259:7: note:   candidate expects 0 arguments, 1 provided
parser.y:155:110: error: no matching function for call to ‘std::vector<Param*>::push_back(Param)’
 | parameters LIST_SEP TYPE NAME {$1->push_back(Param(std::string($3), NULL, std::string($4))); $$ = $1;}
                                                                                                              ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::value_type = Param*]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘Param’ to ‘Param* const&’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = Param*; _Alloc = std::allocator<Param*>; std::vector<_Tp, _Alloc>::value_type = Param*]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘Param’ to ‘Param*&&’
parser.y:156:86: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 | parameters LIST_SEP TYPE multidim NAME {$1->push_back(Param(std::string($3), $4, std::string($5))); $$ = $1;}
                                                                                      ^~~~~~
                                                                                      SquareVal
parser.y:158:44: error: cannot convert ‘char [100]’ to ‘Statement*’ in assignment
 statement_block : OPENBRACE statement_list CLOSEBRACE {$$ = $1;}
                                            ^
parser.y:166:39: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘VarDecVal’; did you mean ‘NameVal’?
 statementsc : declaration {$$ = $1;}
                                       ^        
                                       NameVal
parser.y:180:86: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 | NAME multidim ASSIGN texp {$$ = new ArrayAssign(std::string($1),$2,$4);}
                                                                                      ^     
                                                                                      SquareVal
parser.y:182:13: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 multidim : OPENSQUARE texp CLOSESQUARE {$$ = new std::vector<Square*> {Square($2)};}
             ^~~~~~
             SquareVal
parser.y:182:75: error: no matching function for call to ‘std::vector<Square*>::vector(<brace-enclosed initializer list>)’
 multidim : OPENSQUARE texp CLOSESQUARE {$$ = new std::vector<Square*> {Square($2)};}
                                                                           ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:411:2: note: candidate: template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)
  vector(_InputIterator __first, _InputIterator __last,
  ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:411:2: note:   template argument deduction/substitution failed:
parser.y:182:75: note:   candidate expects 3 arguments, 1 provided
 multidim : OPENSQUARE texp CLOSESQUARE {$$ = new std::vector<Square*> {Square($2)};}
                                                                           ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:383:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = Square*; _Alloc = std::allocator<Square*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Square*>]
       vector(initializer_list<value_type> __l,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:383:7: note:   no known conversion for argument 1 from ‘Square’ to ‘std::initializer_list<Square*>’
/usr/include/c++/7/bits/stl_vector.h:358:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&) [with _Tp = Square*; _Alloc = std::allocator<Square*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Square*>]
       vector(vector&& __rv, const allocator_type& __m)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:358:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:348:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&, const allocator_type&) [with _Tp = Square*; _Alloc = std::allocator<Square*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Square*>]
       vector(const vector& __x, const allocator_type& __a)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:348:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:344:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&) [with _Tp = Square*; _Alloc = std::allocator<Square*>]
       vector(vector&& __x) noexcept
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:344:7: note:   no known conversion for argument 1 from ‘Square’ to ‘std::vector<Square*>&&’
/usr/include/c++/7/bits/stl_vector.h:326:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = Square*; _Alloc = std::allocator<Square*>]
       vector(const vector& __x)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:326:7: note:   no known conversion for argument 1 from ‘Square’ to ‘const std::vector<Square*>&’
/usr/include/c++/7/bits/stl_vector.h:295:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = Square*; _Alloc = std::allocator<Square*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = Square*; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Square*>]
       vector(size_type __n, const value_type& __value,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:295:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:283:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const allocator_type&) [with _Tp = Square*; _Alloc = std::allocator<Square*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Square*>]
       vector(size_type __n, const allocator_type& __a = allocator_type())
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:283:7: note:   no known conversion for argument 1 from ‘Square’ to ‘std::vector<Square*>::size_type {aka long unsigned int}’
/usr/include/c++/7/bits/stl_vector.h:270:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = Square*; _Alloc = std::allocator<Square*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Square*>]
       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:270:7: note:   no known conversion for argument 1 from ‘Square’ to ‘const allocator_type& {aka const std::allocator<Square*>&}’
/usr/include/c++/7/bits/stl_vector.h:259:7: note: candidate: std::vector<_Tp, _Alloc>::vector() [with _Tp = Square*; _Alloc = std::allocator<Square*>]
       vector()
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:259:7: note:   candidate expects 0 arguments, 1 provided
parser.y:183:17: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 | multidim OPENSQUARE texp CLOSESQUARE {$1->push_back(Square($3)); $$ = $1;}
                 ^~~~~~
                 SquareVal
parser.y:183:72: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 | multidim OPENSQUARE texp CLOSESQUARE {$1->push_back(Square($3)); $$ = $1;}
                                                                        ^~~~~ 
                                                                        SquareVal
parser.y:183:93: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 | multidim OPENSQUARE texp CLOSESQUARE {$1->push_back(Square($3)); $$ = $1;}
                                                                                             ^     
                                                                                             SquareVal
parser.y:185:89: error: no matching function for call to ‘FuncCall::FuncCall(std::__cxx11::string, std::vector<Arg*>*&)’
 function_call : NAME OPENPAREN arguments CLOSEPAREN {$$ = new FuncCall(std::string($1),$3);}
                                                                                         ^
In file included from parser.y:6:0:
ast.h:590:2: note: candidate: FuncCall::FuncCall(std::__cxx11::string, Node*)
  FuncCall(std::string name, Node *args){
  ^~~~~~~~
ast.h:590:2: note:   no known conversion for argument 2 from ‘std::vector<Arg*>*’ to ‘Node*’
ast.h:588:7: note: candidate: FuncCall::FuncCall(const FuncCall&)
 class FuncCall: public Statement{
       ^~~~~~~~
ast.h:588:7: note:   candidate expects 1 argument, 2 provided
parser.y:188:68: error: no matching function for call to ‘std::vector<Arg*>::vector(<brace-enclosed initializer list>)’
 arguments : texp {$$ = new std::vector<Arg*> {Arg($1)};}
                                                                    ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:411:2: note: candidate: template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)
  vector(_InputIterator __first, _InputIterator __last,
  ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:411:2: note:   template argument deduction/substitution failed:
parser.y:188:68: note:   candidate expects 3 arguments, 1 provided
 arguments : texp {$$ = new std::vector<Arg*> {Arg($1)};}
                                                                    ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:383:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(initializer_list<value_type> __l,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:383:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘std::initializer_list<Arg*>’
/usr/include/c++/7/bits/stl_vector.h:358:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(vector&& __rv, const allocator_type& __m)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:358:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:348:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(const vector& __x, const allocator_type& __a)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:348:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:344:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>]
       vector(vector&& __x) noexcept
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:344:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘std::vector<Arg*>&&’
/usr/include/c++/7/bits/stl_vector.h:326:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>]
       vector(const vector& __x)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:326:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘const std::vector<Arg*>&’
/usr/include/c++/7/bits/stl_vector.h:295:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = Arg*; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(size_type __n, const value_type& __value,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:295:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:283:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(size_type __n, const allocator_type& __a = allocator_type())
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:283:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘std::vector<Arg*>::size_type {aka long unsigned int}’
/usr/include/c++/7/bits/stl_vector.h:270:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:270:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘const allocator_type& {aka const std::allocator<Arg*>&}’
/usr/include/c++/7/bits/stl_vector.h:259:7: note: candidate: std::vector<_Tp, _Alloc>::vector() [with _Tp = Arg*; _Alloc = std::allocator<Arg*>]
       vector()
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:259:7: note:   candidate expects 0 arguments, 1 provided
parser.y:189:71: error: no matching function for call to ‘std::vector<Arg*>::vector(<brace-enclosed initializer list>)’
 | string {$$ = new std::vector<Arg*> {Arg($1)};}
                                                                       ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:411:2: note: candidate: template<class _InputIterator, class> std::vector<_Tp, _Alloc>::vector(_InputIterator, _InputIterator, const allocator_type&)
  vector(_InputIterator __first, _InputIterator __last,
  ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:411:2: note:   template argument deduction/substitution failed:
parser.y:189:71: note:   candidate expects 3 arguments, 1 provided
 | string {$$ = new std::vector<Arg*> {Arg($1)};}
                                                                       ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:383:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::initializer_list<_Tp>, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(initializer_list<value_type> __l,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:383:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘std::initializer_list<Arg*>’
/usr/include/c++/7/bits/stl_vector.h:358:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(vector&& __rv, const allocator_type& __m)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:358:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:348:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(const vector& __x, const allocator_type& __a)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:348:7: note:   candidate expects 2 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:344:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>&&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>]
       vector(vector&& __x) noexcept
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:344:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘std::vector<Arg*>&&’
/usr/include/c++/7/bits/stl_vector.h:326:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const std::vector<_Tp, _Alloc>&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>]
       vector(const vector& __x)
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:326:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘const std::vector<Arg*>&’
/usr/include/c++/7/bits/stl_vector.h:295:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const value_type&, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::value_type = Arg*; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(size_type __n, const value_type& __value,
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:295:7: note:   candidate expects 3 arguments, 1 provided
/usr/include/c++/7/bits/stl_vector.h:283:7: note: candidate: std::vector<_Tp, _Alloc>::vector(std::vector<_Tp, _Alloc>::size_type, const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::size_type = long unsigned int; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(size_type __n, const allocator_type& __a = allocator_type())
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:283:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘std::vector<Arg*>::size_type {aka long unsigned int}’
/usr/include/c++/7/bits/stl_vector.h:270:7: note: candidate: std::vector<_Tp, _Alloc>::vector(const allocator_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::allocator_type = std::allocator<Arg*>]
       vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:270:7: note:   no known conversion for argument 1 from ‘Arg’ to ‘const allocator_type& {aka const std::allocator<Arg*>&}’
/usr/include/c++/7/bits/stl_vector.h:259:7: note: candidate: std::vector<_Tp, _Alloc>::vector() [with _Tp = Arg*; _Alloc = std::allocator<Arg*>]
       vector()
       ^~~~~~
/usr/include/c++/7/bits/stl_vector.h:259:7: note:   candidate expects 0 arguments, 1 provided
parser.y:190:53: error: no matching function for call to ‘std::vector<Arg*>::push_back(Exp*&)’
 | arguments LIST_SEP texp {$1->push_back($3); $$ = $1;}
                                                     ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::value_type = Arg*]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘Exp*’ to ‘Arg* const&’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::value_type = Arg*]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘Exp*’ to ‘Arg*&&’
parser.y:191:56: error: no matching function for call to ‘std::vector<Arg*>::push_back(String*&)’
 | arguments LIST_SEP string {$1->push_back($3); $$ = $1;}
                                                        ^
In file included from /usr/include/c++/7/vector:64:0,
                 from ast.h:1,
                 from parser.y:6:
/usr/include/c++/7/bits/stl_vector.h:939:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(const value_type&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::value_type = Arg*]
       push_back(const value_type& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:939:7: note:   no known conversion for argument 1 from ‘String*’ to ‘Arg* const&’
/usr/include/c++/7/bits/stl_vector.h:953:7: note: candidate: void std::vector<_Tp, _Alloc>::push_back(std::vector<_Tp, _Alloc>::value_type&&) [with _Tp = Arg*; _Alloc = std::allocator<Arg*>; std::vector<_Tp, _Alloc>::value_type = Arg*]
       push_back(value_type&& __x)
       ^~~~~~~~~
/usr/include/c++/7/bits/stl_vector.h:953:7: note:   no known conversion for argument 1 from ‘String*’ to ‘Arg*&&’
parser.y:208:93: error: no matching function for call to ‘TernaryOperator::TernaryOperator(Exp*&, char [100], Exp*&)’
 | or_exp TQ texp TE or_exp {$$ = TernaryOperator($1,$2,$3);}
                                                                                             ^
In file included from parser.y:6:0:
ast.h:219:2: note: candidate: TernaryOperator::TernaryOperator(Node*, Node*, Node*)
  TernaryOperator(Node *left, Node *middle, Node *right){
  ^~~~~~~~~~~~~~~
ast.h:219:2: note:   no known conversion for argument 2 from ‘char [100]’ to ‘Node*’
ast.h:217:7: note: candidate: constexpr TernaryOperator::TernaryOperator(const TernaryOperator&)
 class TernaryOperator: public Exp{
       ^~~~~~~~~~~~~~~
ast.h:217:7: note:   candidate expects 1 argument, 3 provided
parser.y:211:107: error: no matching function for call to ‘BinaryOperator::BinaryOperator(std::__cxx11::string, Exp*&, char [100])’
 | or_exp OR and_exp {$$ = new BinaryOperator(std::string($2),$1,$2);}
                                                                                                           ^
In file included from parser.y:6:0:
ast.h:185:2: note: candidate: BinaryOperator::BinaryOperator(std::__cxx11::string, Node*, Node*)
  BinaryOperator(std::string op, Node *left, Node *right){
  ^~~~~~~~~~~~~~
ast.h:185:2: note:   no known conversion for argument 3 from ‘char [100]’ to ‘Node*’
ast.h:183:7: note: candidate: BinaryOperator::BinaryOperator(const BinaryOperator&)
 class BinaryOperator: public Exp{
       ^~~~~~~~~~~~~~
ast.h:183:7: note:   candidate expects 1 argument, 3 provided
parser.y:214:107: error: no matching function for call to ‘BinaryOperator::BinaryOperator(std::__cxx11::string, Exp*&, char [100])’
 | and_exp AND eq_exp {$$ = new BinaryOperator(std::string($2),$1,$2);}
                                                                                                           ^
In file included from parser.y:6:0:
ast.h:185:2: note: candidate: BinaryOperator::BinaryOperator(std::__cxx11::string, Node*, Node*)
  BinaryOperator(std::string op, Node *left, Node *right){
  ^~~~~~~~~~~~~~
ast.h:185:2: note:   no known conversion for argument 3 from ‘char [100]’ to ‘Node*’
ast.h:183:7: note: candidate: BinaryOperator::BinaryOperator(const BinaryOperator&)
 class BinaryOperator: public Exp{
       ^~~~~~~~~~~~~~
ast.h:183:7: note:   candidate expects 1 argument, 3 provided
parser.y:216:40: error: expected ‘;’ before ‘}’ token
 eq_exp : rel_exp {$$ = $1};
                                        ^
parser.y:217:107: error: no matching function for call to ‘BinaryOperator::BinaryOperator(std::__cxx11::string, Exp*&, char [100])’
 | eq_exp EQ rel_exp {$$ = new BinaryOperator(std::string($2),$1,$2);}
                                                                                                           ^
In file included from parser.y:6:0:
ast.h:185:2: note: candidate: BinaryOperator::BinaryOperator(std::__cxx11::string, Node*, Node*)
  BinaryOperator(std::string op, Node *left, Node *right){
  ^~~~~~~~~~~~~~
ast.h:185:2: note:   no known conversion for argument 3 from ‘char [100]’ to ‘Node*’
ast.h:183:7: note: candidate: BinaryOperator::BinaryOperator(const BinaryOperator&)
 class BinaryOperator: public Exp{
       ^~~~~~~~~~~~~~
ast.h:183:7: note:   candidate expects 1 argument, 3 provided
parser.y:220:107: error: no matching function for call to ‘BinaryOperator::BinaryOperator(std::__cxx11::string, Exp*&, char [100])’
 | rel_exp REL add_exp {$$ = new BinaryOperator(std::string($2),$1,$2);}
                                                                                                           ^
In file included from parser.y:6:0:
ast.h:185:2: note: candidate: BinaryOperator::BinaryOperator(std::__cxx11::string, Node*, Node*)
  BinaryOperator(std::string op, Node *left, Node *right){
  ^~~~~~~~~~~~~~
ast.h:185:2: note:   no known conversion for argument 3 from ‘char [100]’ to ‘Node*’
ast.h:183:7: note: candidate: BinaryOperator::BinaryOperator(const BinaryOperator&)
 class BinaryOperator: public Exp{
       ^~~~~~~~~~~~~~
ast.h:183:7: note:   candidate expects 1 argument, 3 provided
parser.y:223:107: error: no matching function for call to ‘BinaryOperator::BinaryOperator(std::__cxx11::string, Exp*&, char [100])’
 | add_exp ADD mul_exp {$$ = new BinaryOperator(std::string($2),$1,$2);}
                                                                                                           ^
In file included from parser.y:6:0:
ast.h:185:2: note: candidate: BinaryOperator::BinaryOperator(std::__cxx11::string, Node*, Node*)
  BinaryOperator(std::string op, Node *left, Node *right){
  ^~~~~~~~~~~~~~
ast.h:185:2: note:   no known conversion for argument 3 from ‘char [100]’ to ‘Node*’
ast.h:183:7: note: candidate: BinaryOperator::BinaryOperator(const BinaryOperator&)
 class BinaryOperator: public Exp{
       ^~~~~~~~~~~~~~
ast.h:183:7: note:   candidate expects 1 argument, 3 provided
parser.y:226:107: error: no matching function for call to ‘BinaryOperator::BinaryOperator(std::__cxx11::string, Exp*&, char [100])’
 | mul_exp MUL exp {$$ = new BinaryOperator(std::string($2),$1,$2);}
                                                                                                           ^
In file included from parser.y:6:0:
ast.h:185:2: note: candidate: BinaryOperator::BinaryOperator(std::__cxx11::string, Node*, Node*)
  BinaryOperator(std::string op, Node *left, Node *right){
  ^~~~~~~~~~~~~~
ast.h:185:2: note:   no known conversion for argument 3 from ‘char [100]’ to ‘Node*’
ast.h:183:7: note: candidate: BinaryOperator::BinaryOperator(const BinaryOperator&)
 class BinaryOperator: public Exp{
       ^~~~~~~~~~~~~~
ast.h:183:7: note:   candidate expects 1 argument, 3 provided
parser.y:228:40: error: cannot convert ‘Term*’ to ‘Exp*’ in assignment
 exp : term {$$ = $1;}
                                        ^
parser.y:236:43: error: invalid conversion from ‘char*’ to ‘char’ [-fpermissive]
 | CHARV  {$$ = new Char($1);}
                                           ^    
In file included from parser.y:6:0:
ast.h:102:2: note:   initializing argument 1 of ‘Char::Char(char)’
  Char(char val){
  ^~~~
parser.y:237:41: error: cannot convert ‘Exp*’ to ‘Term*’ in assignment
 | OPENPAREN texp CLOSEPAREN {$$ = $2;}
                                         ^
parser.y:238:80: error: ‘YYSTYPE {aka union YYSTYPE}’ has no member named ‘Square’; did you mean ‘SquareVal’?
 | NAME multidim {$$ = new MultiDimArr(std::string($1),$2);}
                                                                                ^     
                                                                                SquareVal
parser.y:239:46: error: cannot convert ‘FuncCall*’ to ‘Term*’ in assignment
 | function_call { $$ = $1;}
                                              ^
